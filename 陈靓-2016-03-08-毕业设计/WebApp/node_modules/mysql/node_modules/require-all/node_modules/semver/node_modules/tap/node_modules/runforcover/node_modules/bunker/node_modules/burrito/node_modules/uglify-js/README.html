<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
               "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"
lang="en" xml:lang="en">
<head>
<title>UglifyJS -- a JavaScript parser/compressor/beautifier</title>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
<meta name="generator" content="Org-mode"/>
<meta name="generated" content="2011-08-29 19:17:55 EEST"/>
<meta name="author" content="Mihai Bazon"/>
<meta name="description" content="a JavaScript parser/compressor/beautifier in JavaScript"/>
<meta name="keywords" content="javascript, js, parser, compiler, compressor, mangle, minify, minifier"/>
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  html { font-family: Times, serif; font-size: 12pt; }
  .title  { text-align: center; }
  .todo   { color: red; }
  .done   { color: green; }
  .tag    { background-color: #add8e6; font-weight:normal }
  .target { }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  p.verse { margin-left: 3% }
  pre {
	border: 1pt solid #AEBDCC;
	background-color: #F3F5F7;
	padding: 5pt;
	font-family: courier, monospace;
        font-size: 90%;
        overflow:auto;
  }
  table { border-collapse: collapse; }
  td, th { vertical-align: top; }
  dt { font-weight: bold; }
  div.figure { padding: 0.5em; }
  div.figure p { text-align: center; }
  textarea { overflow-x: auto; }
  .linenr { font-size:smaller }
  .code-highlighted {background-color:#ffff00;}
  .org-info-js_info-navigation { border-style:none; }
  #org-info-js_console-label { font-size:10px; font-weight:bold;
                               white-space:nowrap; }
  .org-info-js_search-highlight {background-color:#ffff00; color:#000000;
                                 font-weight:bold; }
  /*]]>*/-->
</style>
<link rel="stylesheet" type="text/css" href="docstyle.css" />
<script type="text/javascript">
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>

</head>
<body>
<div id="content">

<h1 class="title">UglifyJS &ndash; a JavaScript parser/compressor/beautifier</h1>


<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">1 UglifyJS &mdash; a JavaScript parser/compressor/beautifier </a>
<ul>
<li><a href="#sec-1_1">1.1 Unsafe transformations </a>
<ul>
<li><a href="#sec-1_1_1">1.1.1 Calls involving the global Array constructor </a></li>
<li><a href="#sec-1_1_2">1.1.2 <code>obj.toString()</code> ==&gt; <code>obj+“”</code> </a></li>
</ul>
</li>
<li><a href="#sec-1_2">1.2 Install (NPM) </a></li>
<li><a href="#sec-1_3">1.3 Install latest code from GitHub </a></li>
<li><a href="#sec-1_4">1.4 Usage </a>
<ul>
<li><a href="#sec-1_4_1">1.4.1 API </a></li>
<li><a href="#sec-1_4_2">1.4.2 Beautifier shortcoming &ndash; no more comments </a></li>
<li><a href="#sec-1_4_3">1.4.3 Use as a code pre-processor </a></li>
</ul>
</li>
<li><a href="#sec-1_5">1.5 Compression &ndash; how good is it? </a></li>
<li><a href="#sec-1_6">1.6 Bugs? </a></li>
<li><a href="#sec-1_7">1.7 Links </a></li>
<li><a href="#sec-1_8">1.8 License </a></li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-1" class="outline-2">
<h2 id="sec-1"><span class="section-number-2">1</span> UglifyJS &mdash; a JavaScript parser/compressor/beautifier </h2>
<div class="outline-text-2" id="text-1">


<p>
This package implements a general-purpose JavaScript
parser/compressor/beautifier toolkit.  It is developed on <a href="http://nodejs.org/">NodeJS</a>, but it
should work on any JavaScript platform supporting the CommonJS module system
(and if your platform of choice doesn't support CommonJS, you can easily
implement it, or discard the <code>exports.*</code> lines from UglifyJS sources).
</p>
<p>
The tokenizer/parser generates an abstract syntax tree from JS code.  You
can then traverse the AST to learn more about the code, or do various
manipulations on it.  This part is implemented in <a href="../lib/parse-js.js">parse-js.js</a> and it's a
port to JavaScript of the excellent <a href="http://marijn.haverbeke.nl/parse-js/">parse-js</a> Common Lisp library from <a href="http://marijn.haverbeke.nl/">Marijn Haverbeke</a>.
</p>
<p>
( See <a href="http://github.com/mishoo/cl-uglify-js">cl-uglify-js</a> if you're looking for the Common Lisp version of
UglifyJS. )
</p>
<p>
The second part of this package, implemented in <a href="../lib/process.js">process.js</a>, inspects and
manipulates the AST generated by the parser to provide the following:
</p>
<ul>
<li>
ability to re-generate JavaScript code from the AST.  Optionally
indented&mdash;you can use this if you want to “beautify” a program that has
been compressed, so that you can inspect the source.  But you can also run
our code generator to print out an AST without any whitespace, so you
achieve compression as well.

</li>
<li>
shorten variable names (usually to single characters).  Our mangler will
analyze the code and generate proper variable names, depending on scope
and usage, and is smart enough to deal with globals defined elsewhere, or
with <code>eval()</code> calls or <code>with{}</code> statements.  In short, if <code>eval()</code> or
<code>with{}</code> are used in some scope, then all variables in that scope and any
variables in the parent scopes will remain unmangled, and any references
to such variables remain unmangled as well.

</li>
<li>
various small optimizations that may lead to faster code but certainly
lead to smaller code.  Where possible, we do the following:

<ul>
<li>
foo["bar"]  ==&gt;  foo.bar

</li>
<li>
remove block brackets <code>{}</code>

</li>
<li>
join consecutive var declarations:
var a = 10; var b = 20; ==&gt; var a=10,b=20;

</li>
<li>
resolve simple constant expressions: 1 +2 * 3 ==&gt; 7.  We only do the
replacement if the result occupies less bytes; for example 1/3 would
translate to 0.333333333333, so in this case we don't replace it.

</li>
<li>
consecutive statements in blocks are merged into a sequence; in many
cases, this leaves blocks with a single statement, so then we can remove
the block brackets.

</li>
<li>
various optimizations for IF statements:

<ul>
<li>
if (foo) bar(); else baz(); ==&gt; foo?bar():baz();
</li>
<li>
if (!foo) bar(); else baz(); ==&gt; foo?baz():bar();
</li>
<li>
if (foo) bar(); ==&gt; foo&amp;&amp;bar();
</li>
<li>
if (!foo) bar(); ==&gt; foo||bar();
</li>
<li>
if (foo) return bar(); else return baz(); ==&gt; return foo?bar():baz();
</li>
<li>
if (foo) return bar(); else something(); ==&gt; {if(foo)return bar();something()}

</li>
</ul>
</li>
<li>
remove some unreachable code and warn about it (code that follows a
<code>return</code>, <code>throw</code>, <code>break</code> or <code>continue</code> statement, except
function/variable declarations).

</li>
<li>
act a limited version of a pre-processor (c.f. the pre-processor of
C/C++) to allow you to safely replace selected global symbols with
specified values.  When combined with the optimisations above this can
make UglifyJS operate slightly more like a compilation process, in
that when certain symbols are replaced by constant values, entire code
blocks may be optimised away as unreachable.
</li>
</ul>
</li>
</ul>



</div>

<div id="outline-container-1_1" class="outline-3">
<h3 id="sec-1_1"><span class="section-number-3">1.1</span> <span class="target">Unsafe transformations</span>  </h3>
<div class="outline-text-3" id="text-1_1">


<p>
The following transformations can in theory break code, although they're
probably safe in most practical cases.  To enable them you need to pass the
<code>--unsafe</code> flag.
</p>

</div>

<div id="outline-container-1_1_1" class="outline-4">
<h4 id="sec-1_1_1"><span class="section-number-4">1.1.1</span> Calls involving the global Array constructor </h4>
<div class="outline-text-4" id="text-1_1_1">


<p>
The following transformations occur:
</p>



<pre class="src src-js"><span style="color: #a020f0;">new</span> <span style="color: #228b22;">Array</span>(1, 2, 3, 4)  =&gt; [1,2,3,4]
Array(a, b, c)         =&gt; [a,b,c]
<span style="color: #a020f0;">new</span> <span style="color: #228b22;">Array</span>(5)           =&gt; Array(5)
<span style="color: #a020f0;">new</span> <span style="color: #228b22;">Array</span>(a)           =&gt; Array(a)
</pre>



<p>
These are all safe if the Array name isn't redefined.  JavaScript does allow
one to globally redefine Array (and pretty much everything, in fact) but I
personally don't see why would anyone do that.
</p>
<p>
UglifyJS does handle the case where Array is redefined locally, or even
globally but with a <code>function</code> or <code>var</code> declaration.  Therefore, in the
following cases UglifyJS <b>doesn't touch</b> calls or instantiations of Array:
</p>



<pre class="src src-js"><span style="color: #b22222;">// </span><span style="color: #b22222;">case 1.  globally declared variable
</span>  <span style="color: #a020f0;">var</span> <span style="color: #b8860b;">Array</span>;
  <span style="color: #a020f0;">new</span> <span style="color: #228b22;">Array</span>(1, 2, 3);
  Array(a, b);

  <span style="color: #b22222;">// </span><span style="color: #b22222;">or (can be declared later)
</span>  <span style="color: #a020f0;">new</span> <span style="color: #228b22;">Array</span>(1, 2, 3);
  <span style="color: #a020f0;">var</span> <span style="color: #b8860b;">Array</span>;

  <span style="color: #b22222;">// </span><span style="color: #b22222;">or (can be a function)
</span>  <span style="color: #a020f0;">new</span> <span style="color: #228b22;">Array</span>(1, 2, 3);
  <span style="color: #a020f0;">function</span> <span style="color: #0000ff;">Array</span>() { ... }

<span style="color: #b22222;">// </span><span style="color: #b22222;">case 2.  declared in a function
</span>  (<span style="color: #a020f0;">function</span>(){
    a = <span style="color: #a020f0;">new</span> <span style="color: #228b22;">Array</span>(1, 2, 3);
    b = Array(5, 6);
    <span style="color: #a020f0;">var</span> <span style="color: #b8860b;">Array</span>;
  })();

  <span style="color: #b22222;">// </span><span style="color: #b22222;">or
</span>  (<span style="color: #a020f0;">function</span>(<span style="color: #b8860b;">Array</span>){
    <span style="color: #a020f0;">return</span> Array(5, 6, 7);
  })();

  <span style="color: #b22222;">// </span><span style="color: #b22222;">or
</span>  (<span style="color: #a020f0;">function</span>(){
    <span style="color: #a020f0;">return</span> <span style="color: #a020f0;">new</span> <span style="color: #228b22;">Array</span>(1, 2, 3, 4);
    <span style="color: #a020f0;">function</span> <span style="color: #0000ff;">Array</span>() { ... }
  })();

  <span style="color: #b22222;">// </span><span style="color: #b22222;">etc.
</span></pre>



</div>

</div>

<div id="outline-container-1_1_2" class="outline-4">
<h4 id="sec-1_1_2"><span class="section-number-4">1.1.2</span> <code>obj.toString()</code> ==&gt; <code>obj+“”</code> </h4>
<div class="outline-text-4" id="text-1_1_2">


</div>
</div>

</div>

<div id="outline-container-1_2" class="outline-3">
<h3 id="sec-1_2"><span class="section-number-3">1.2</span> Install (NPM) </h3>
<div class="outline-text-3" id="text-1_2">


<p>
UglifyJS is now available through NPM &mdash; <code>npm install uglify-js</code> should do
the job.
</p>
</div>

</div>

<div id="outline-container-1_3" class="outline-3">
<h3 id="sec-1_3"><span class="section-number-3">1.3</span> Install latest code from GitHub </h3>
<div class="outline-text-3" id="text-1_3">





<pre class="src src-sh"><span style="color: #b22222;">## </span><span style="color: #b22222;">clone the repository
</span>mkdir -p /where/you/wanna/put/it
<span style="color: #da70d6;">cd</span> /where/you/wanna/put/it
git clone git://github.com/mishoo/UglifyJS.git

<span style="color: #b22222;">## </span><span style="color: #b22222;">make the module available to Node
</span>mkdir -p ~/.node_libraries/
<span style="color: #da70d6;">cd</span> ~/.node_libraries/
ln -s /where/you/wanna/put/it/UglifyJS/uglify-js.js

<span style="color: #b22222;">## </span><span style="color: #b22222;">and if you want the CLI script too:
</span>mkdir -p ~/bin
<span style="color: #da70d6;">cd</span> ~/bin
ln -s /where/you/wanna/put/it/UglifyJS/bin/uglifyjs
  <span style="color: #b22222;"># </span><span style="color: #b22222;">(then add ~/bin to your $PATH if it's not there already)
</span></pre>



</div>

</div>

<div id="outline-container-1_4" class="outline-3">
<h3 id="sec-1_4"><span class="section-number-3">1.4</span> Usage </h3>
<div class="outline-text-3" id="text-1_4">


<p>
There is a command-line tool that exposes the functionality of this library
for your shell-scripting needs:
</p>



<pre class="src src-sh">uglifyjs [ options... ] [ filename ]
</pre>



<p>
<code>filename</code> should be the last argument and should name the file from which
to read the JavaScript code.  If you don't specify it, it will read code
from STDIN.
</p>
<p>
Supported options:
</p>
<ul>
<li>
<code>-b</code> or <code>--beautify</code> &mdash; output indented code; when passed, additional
options control the beautifier:

<ul>
<li>
<code>-i N</code> or <code>--indent N</code> &mdash; indentation level (number of spaces)

</li>
<li>
<code>-q</code> or <code>--quote-keys</code> &mdash; quote keys in literal objects (by default,
only keys that cannot be identifier names will be quotes).

</li>
</ul>
</li>
<li>
<code>--ascii</code> &mdash; pass this argument to encode non-ASCII characters as
<code>\uXXXX</code> sequences.  By default UglifyJS won't bother to do it and will
output Unicode characters instead.  (the output is always encoded in UTF8,
but if you pass this option you'll only get ASCII).

</li>
<li>
<code>-nm</code> or <code>--no-mangle</code> &mdash; don't mangle variable names

</li>
<li>
<code>-ns</code> or <code>--no-squeeze</code> &mdash; don't call <code>ast_squeeze()</code> (which does various
optimizations that result in smaller, less readable code).

</li>
<li>
<code>-mt</code> or <code>--mangle-toplevel</code> &mdash; mangle names in the toplevel scope too
(by default we don't do this).

</li>
<li>
<code>--no-seqs</code> &mdash; when <code>ast_squeeze()</code> is called (thus, unless you pass
<code>--no-squeeze</code>) it will reduce consecutive statements in blocks into a
sequence.  For example, "a = 10; b = 20; foo();" will be written as
"a=10,b=20,foo();".  In various occasions, this allows us to discard the
block brackets (since the block becomes a single statement).  This is ON
by default because it seems safe and saves a few hundred bytes on some
libs that I tested it on, but pass <code>--no-seqs</code> to disable it.

</li>
<li>
<code>--no-dead-code</code> &mdash; by default, UglifyJS will remove code that is
obviously unreachable (code that follows a <code>return</code>, <code>throw</code>, <code>break</code> or
<code>continue</code> statement and is not a function/variable declaration).  Pass
this option to disable this optimization.

</li>
<li>
<code>-nc</code> or <code>--no-copyright</code> &mdash; by default, <code>uglifyjs</code> will keep the initial
comment tokens in the generated code (assumed to be copyright information
etc.).  If you pass this it will discard it.

</li>
<li>
<code>-o filename</code> or <code>--output filename</code> &mdash; put the result in <code>filename</code>.  If
this isn't given, the result goes to standard output (or see next one).

</li>
<li>
<code>--overwrite</code> &mdash; if the code is read from a file (not from STDIN) and you
pass <code>--overwrite</code> then the output will be written in the same file.

</li>
<li>
<code>--ast</code> &mdash; pass this if you want to get the Abstract Syntax Tree instead
of JavaScript as output.  Useful for debugging or learning more about the
internals.

</li>
<li>
<code>-v</code> or <code>--verbose</code> &mdash; output some notes on STDERR (for now just how long
each operation takes).

</li>
<li>
<code>-d SYMBOL[=VALUE]</code> or <code>--define SYMBOL[=VALUE]</code> &mdash; will replace
all instances of the specified symbol where used as an identifier
(except where symbol has properly declared by a var declaration or
use as function parameter or similar) with the specified value. This
argument may be specified multiple times to define multiple
symbols - if no value is specified the symbol will be replaced with
the value <code>true</code>, or you can specify a numeric value (such as
<code>1024</code>), a quoted string value (such as ="object"= or
='https://github.com'<code>), or the name of another symbol or keyword   (such as =null</code> or <code>document</code>).  
This allows you, for example, to assign meaningful names to key
constant values but discard the symbolic names in the uglified
version for brevity/efficiency, or when used wth care, allows
UglifyJS to operate as a form of <b>conditional compilation</b>
whereby defining appropriate values may, by dint of the constant
folding and dead code removal features above, remove entire
superfluous code blocks (e.g. completely remove instrumentation or
trace code for production use).
Where string values are being defined, the handling of quotes are
likely to be subject to the specifics of your command shell
environment, so you may need to experiment wi
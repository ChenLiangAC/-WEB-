#!/usr/bin/env node

/*
 * Expresso
 * Copyright(c) TJ Holowaychuk <tj@vision-media.ca>
 * (MIT Licensed)
 */

/**
 * Module dependencies.
 */

var assert = require('assert'),
    childProcess = require('child_process'),
    http = require('http'),
    path = require('path'),
    sys = require('sys'),
    cwd = process.cwd(),
    fs = require('fs'),
    defer;

/**
 * Setup the regex which is used to match test files.
 * Adjust it to include coffeescript files if CS is available
 */
var file_matcher = /\.js$/;
try {
  require('coffee-script');
  file_matcher = /\.(js|coffee)$/;
} catch (e) {}

/**
 * Expresso version.
 */

var version = '0.7.9';

/**
 * Failure count.
 */

var failures = 0;


/**
 * Number of tests executed.
 */

var testcount = 0;

/**
 * Whitelist of tests to run.
 */

var only = [];

/**
 * Boring output.
 */

var boring = false;

/**
 * Growl notifications.
 */

var growl = false;

/**
 * Server port.
 */

var port = 5555;

/**
 * Execute serially.
 */

var serial = false;

/**
 * Default timeout.
 */

var timeout = 2000;

/**
 * Quiet output.
 */

var quiet = false;

/**
 * JSON code coverage report
 */
var jsonCoverage = false;
var jsonFile;

/**
 * Usage documentation.
 */

var usage = ''
    + '[bold]{Usage}: expresso [options] <file ...>'
    + '\n'
    + '\n[bold]{Options}:'
    + '\n  -g, --growl          Enable growl notifications'
    + '\n  -c, --coverage       Generate and report test coverage'
    + '\n  -j, --json PATH      Used in conjunction with --coverage, ouput JSON coverage to PATH'
    + '\n  -q, --quiet          Suppress coverage report if 100%'
    + '\n  -t, --timeout MS     Timeout in milliseconds, defaults to 2000'
    + '\n  -r, --require PATH   Require the given module path'
    + '\n  -o, --only TESTS     Execute only the comma sperated TESTS (can be set several times)'
    + '\n  -I, --include PATH   Unshift the given path to require.paths'
    + '\n  -p, --port NUM       Port number for test servers, starts at 5555'
    + '\n  -s, --serial         Execute tests serially'
    + '\n  -b, --boring         Suppress ansi-escape colors'
    + '\n  -v, --version        Output version number'
    + '\n  -h, --help           Display help information'
    + '\n';

// Parse arguments

var files = [],
    args = process.argv.slice(2);

while (args.length) {
    var arg = args.shift();
    switch (arg) {
        case '-h':
        case '--help':
            print(usage + '\n');
            process.exit(1);
            break;
        case '-v':
        case '--version':
            sys.puts(version);
            process.exit(1);
            break;
        case '-i':
        case '-I':
        case '--include':
            if (arg = args.shift()) {
                require.paths.unshift(arg);
            } else {
                throw new Error('--include requires a path');
            }
            break;
        case '-o':
        case '--only':
            if (arg = args.shift()) {
                only = only.concat(arg.split(/ *, */));
            } else {
                throw new Error('--only requires comma-separated test names');
            }
            break;
        case '-p':
        case '--port':
            if (arg = args.shift()) {
                port = parseInt(arg, 10);
            } else {
                throw new Error('--port requires a number');
            }
            break;
        case '-r':
        case '--require':
            if (arg = args.shift()) {
                require(arg);
            } else {
                throw new Error('--require requires a path');
            }
            break;
        case '-t':
        case '--timeout':
          if (arg = args.shift()) {
            timeout = parseInt(arg, 10);
          } else {
            throw new Error('--timeout requires an argument');
          }
          break;
        case '-c':
        case '--cov':
        case '--coverage':
            defer = true;
            childProcess.exec('rm -fr lib-cov && node-jscoverage lib lib-cov', function(err){
                if (err) throw err;
                require.paths.unshift('lib-cov');
                run(files);
            })
            break;
        case '-q':
        case '--quiet':
            quiet = true;
            break;
        case '-b':
        case '--boring':
            boring = true;
            break;
        case '-g':
        case '--growl':
            growl = true;
            break;
        case '-s':
        case '--serial':
            serial = true;
            break;
        case '-j':
        case '--json':
            jsonCoverage = true;
            if (arg = args.shift()) {
                jsonFile = path.normalize(arg);
            } else {
                throw new Error('--json requires file to write to');
            }
            break;
        default:
            if (file_matcher.test(arg)) {
                files.push(arg);
            }
            break;
    }
}

/**
 * Colorized sys.error().
 *
 * @param {String} str
 */

function print(str){
    sys.error(colorize(str));
}

/**
 * Colorize the given string using ansi-escape sequences.
 * Disabled when --boring is set.
 *
 * @param {String} str
 * @return {String}
 */

function colorize(str){
    var colors = { bold: 1, red: 31, green: 32, yellow: 33 };
    return str.replace(/\[(\w+)\]\{([^]*?)\}/g, function(_, color, str){
        return boring
            ? str
            : '\x1B[' + colors[color] + 'm' + str + '\x1B[0m';
    });
}

// Alias deepEqual as eql for complex equality

assert.eql = assert.deepEqual;

/**
 * Assert that `val` is null.
 *
 * @param